import os
from telegram import Update
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    ContextTypes,
    filters,
    ConversationHandler
)
import logging
from datetime import datetime, timedelta
import random
from flask import Flask, request

# Configuraci√≥n b√°sica
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Configuraci√≥n de la aplicaci√≥n Flask para Render
app = Flask(__name__)

@app.route('/')
def home():
    return "¬°Sweet Spot Bot est√° activo! üç∞"

# Estados de la conversaci√≥n
WAITING_RESPONSE = 1

# Configuraci√≥n anti-spam
MAX_REPEATED_MESSAGES = 3
MESSAGE_TIME_WINDOW = 10
COOLDOWN_TIME = 30

# Datos de tu emprendimiento con respuestas m√°s conversacionales
RESPUESTAS = {
    "saludo": [
        "¬°Hola {nombre}! ¬øC√≥mo est√°s? üòä\n\n‚ú® *Bienvenido/a a mi peque√±o emprendimiento Sweet Spot!* ‚ú®\n\nT√∫ apoyo lo hace grande üíï\n\n¬øEn qu√© podemos ayudarte hoy? üç∞Puedes preguntarme sobre:\n"
        "- Productos disponibles\n- Precios\n- Env√≠os\n- Contacto\n- Ubicaci√≥n\n- Tortas completas\n"
        "- O cualquier otra inquietud que tengas\n\n"
        "¬°Estoy aqu√≠ para ayudarte! üíå"
    ],
    "hola": [
        "üòä ¬°Hola! ¬øCon qu√© informaci√≥n puedo ayudarte sobre Sweet Spot el dia de hoy? üç™",
    ],
    "bien": [
        "Bien gracias üòä, ¬øCon qu√© informaci√≥n puedo ayudarte sobre nosotros Sweet Spot? üéÇ",
        "Estoy muy bien, gracias por preguntar üòä ¬øEn qu√© puedo ayudarte hoy? üíñ"
    ],
    "precios": [
        "üí∞ Nuestros precios y productos:\n\nüç∞ Tortas por porci√≥n:\n- Chocolate: 3$ üç´\n- Tres leches: 3$ ü•õ\n- Vainilla con arequipe: 2.5$ ÔøΩ\n- Choco quesillo: 3.5$ üçÆ\n\nüç™ Galletas polvorosas:\n- 1.5$ al detal\n- 1$ al mayor (a partir de 6 unidades)\n\n¬°üòä En qu√© otra cosa puedo ayudarte!",
        "Aqu√≠ tienes nuestros precios actualizados productos:\n\nüéÇ Tortas por porci√≥n:\n‚Ä¢ Chocolate: 3$ üç´\n‚Ä¢ Tres leches: 3$ ü•õ\n‚Ä¢ Vainilla con arequipe: 2.5$ üßÅ\n‚Ä¢ Choco quesillo: 3.5$ üçÆ\n\nüç™ Galletas:\n‚Ä¢ 1.5$ unidad\n‚Ä¢ 1$ c/u al mayor (6+ unidades)\n\n¬øNecesitas informaci√≥n sobre algo m√°s? üòä"
    ],
    "envios": [
        "üöö Env√≠os a toda Cabimas:\n\n‚Ä¢ Costo: Dependiendo de la zona üó∫Ô∏è\n‚Ä¢ Envio gratis por compras mayores a 10$ üí∏\n\n¬°üòä En qu√© otra cosa puedo ayudarte!",
        "üì¶ Nuestro servicio de env√≠os:\n\n‚Ä¢ Cubrimos toda Cabimas üèôÔ∏è\n‚Ä¢ Costo var√≠a seg√∫n la zona üó∫Ô∏è\n‚Ä¢ ¬°Env√≠o gratis para pedidos mayores a 10$! üí∞\n\n¬øQuieres saber algo m√°s? üòä"
    ],
    "contacto": [
        "üìû CEO: Rossana Hernandez\n\n Cont√°ctanos:\n\nWhatsApp: 0412-1422179 üì±\nInstagram: @Sweetspot_29 üì∏\n\nüòä ¬øNecesitas ayuda en algo m√°s?",
        "üì≤ CEO: Rossana Hernandez\n\n Puedes comunicarte con nosotros por:\n\n‚Ä¢ WhatsApp: 0412-1422179\n‚Ä¢ Instagram: @Sweetspot_29\n\nEstamos aqu√≠ para atenderte. ¬øAlgo m√°s en lo que pueda ayudar? üíñ"
    ],
    "pagos": [
        "üí≥ Aceptamos:\n\n‚Ä¢ Efectivo üíµ\n‚Ä¢ Transferencia üè¶\n‚Ä¢ Pago m√≥vil üì±\n\nüòä ¬øTienes alguna otra inquietud?",
        "üí∞ M√©todos de pago disponibles:\n\n‚Ä¢ Efectivo üíµ\n‚Ä¢ Transferencia bancaria üè¶\n‚Ä¢ Pago m√≥vel üì≤\n\n¬øNecesitas informaci√≥n adicional? üòä"
    ],
    "ubicacion": [
    "Aun no contamos con tienda fisica somos tinda online contactanosüòä ¬øTienes alguna otra inquietud?",
],
    "tortas_completas": [
        "üéÇ Tortas completas:\n\n‚Ä¢ 1KG:\n- Chocolate: 33$ üç´\n- Tres leches: 33$ ü•õ\n- Vainilla con arequipe: 27$ ÔøΩ\n- Choco quesillo: 39$ üçÆ\n\n‚Ä¢ 1/2KG:\n- Chocolate: 16$ üç´\n- Tres leches: 16$ ü•õ\n- Vainilla con arequipe: 15$ üßÅ\n- Choco quesillo: 20$ üçÆ\n\n‚Ä¢ 1/4KG:\n- Chocolate: 9$ üç´\n- Tres leches: 9$ ü•õ\n- Vainilla con arequipe: 8$ üßÅ\n- Choco quesillo: 11$ üçÆ\n\n¬°üòä Para realizar pedidos cont√°ctanos! üìû",
        "üç∞ Precios de tortas completas:\n\n‚Ä¢ 1KG:\n- Chocolate: 33$ üç´\n- Tres leches: 33$ ü•õ\n- Vainilla con arequipe: 27$ üßÅ\n- Choco quesillo: 39$ üçÆ\n\n‚Ä¢ 1/2KG:\n- Chocolate: 16$ üç´\n- Tres leches: 16$ ü•õ\n- Vainilla con arequipe: 15$ üßÅ\n- Choco quesillo: 20$ üçÆ\n\n‚Ä¢ 1/4KG:\n- Chocolate: 9$ ÔøΩ\n- Tres leches: 9$ ü•õ\n- Vainilla con arequipe: 8$ üßÅ\n- Choco quesillo: 11$ üçÆ\n\n¬øQuieres hacer un pedido o necesitas otra informaci√≥n? üòä"
    ],
    "devoluciones": [
        "üîÑ No se aceptan devoluciones ‚ùå",
        "‚ö†Ô∏è Lamentablemente no manejamos pol√≠ticas de devoluci√≥n. ¬øPuedo ayudarte con algo m√°s? üòä"
    ],
    "despedida": [
        "¬°Gracias por contactar a Sweet Spot! Vuelve pronto üòä üç∞",
        "¬°Fue un placer ayudarte! Que tengas un dulce d√≠a üéÇ üíù",
        "¬°Hasta luego! Esperamos verte de nuevo en Sweet Spot üíï üç™"
    ],
    "no_entendido": [
        "ü§î No entend√≠ tu pregunta. ¬øPodr√≠as reformularla?",
        "üòÖ Disculpa, no estoy seguro de entender. ¬øPuedes decirlo de otra manera?",
        "‚ùì ¬øTe refieres a informaci√≥n sobre productos, precios, env√≠os o algo m√°s?"
    ],
    "spam": [
        "‚è≥ Parece que est√°s enviando muchos mensajes seguidos. Voy a hacer una pausa por un momento.",
        "ü§ñ Voy a tomarme un breve descanso. Por favor env√≠a tu consulta de nuevo m√°s tarde.",
        "üö´ Para evitar spam, necesito esperar un momento antes de responder m√°s mensajes."
    ],
    "repetido": [
        "üîÅ Ya respond√≠ a eso anteriormente. ¬øHay algo m√°s en lo que pueda ayudarte? üòä",
        "üîÑ Creo que ya hablamos sobre esto. ¬øQuieres informaci√≥n sobre otro tema? üç∞",
        "‚ùì ¬øTe gustar√≠a que repita la informaci√≥n o prefieres preguntar sobre otra cosa? üíñ"
    ]
}

# Diccionario para mantener el contexto de la conversaci√≥n
conversaciones = {}
# Diccionario para control de spam
user_spam_control = {}


def determinar_tema(texto):
    texto = texto.lower()
    
    if any(palabra in texto for palabra in ['hola', 'hi', 'buenos d√≠as', 'buenas tardes', 'buenas noches']):
        return 'hola'
    elif any(palabra in texto for palabra in ['y tu']):
        return 'bien'
    elif any(palabra in texto for palabra in ['precio', 'cost√≥', 'valor', 'cu√°nto sale', 'precios', 'cuanto vale''producto', 'productos', 'servicio', 'qu√© venden', 'qu√© ofrecen']):
        return 'precios'
    elif any(palabra in texto for palabra in ['env√≠o', 'envios', 'entrega', 'cu√°ndo llega', 'domicilio']):
        return 'envios'
    elif any(palabra in texto for palabra in ['contacto', 'hablar', 'whatsapp', 'tel√©fono', 'instagram', 'redes']):
        return 'contacto'
    elif any(palabra in texto for palabra in ['pago', 'pagos', 'tarjeta', 'pago movil', 'transferencia']):
        return 'pagos'
    elif any(palabra in texto for palabra in ['torta', 'completa', 'completas', 'al mayor', 'entera']):
        return 'tortas_completas'
    elif any(palabra in texto for palabra in ['ubicacion', 'donde se encuentran', 'donde estan ubicados', 'como encontralos','ubicaci√≥n', 'son tienda fisica', 'direcci√≥n','direccion']):
        return 'ubicacion'
    elif any(palabra in texto for palabra in ['devoluci√≥n', 'cambio']):
        return 'devoluciones'
    elif any(palabra in texto for palabra in [' gracias por la ayuda', 'thanks', 'adi√≥s', 'chao', 'hasta luego']):
        return 'despedida'
    else:
        return None

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    respuesta = random.choice(RESPUESTAS["saludo"]).format(nombre=user.first_name)
    await update.message.reply_text(respuesta, parse_mode='Markdown')
    
    # Iniciar contexto de conversaci√≥n
    conversaciones[user.id] = {
        'ultimo_tema': None,
        'hora_inicio': datetime.now(),
        'pasos': 0,
        'ultimo_mensaje': None,
        'repeticiones': 0
    }
    
    # Iniciar control de spam
    user_spam_control[user.id] = {
        'last_message_time': datetime.now(),
        'message_count': 0,
        'in_cooldown': False,
        'cooldown_until': None
    }
    
    return WAITING_RESPONSE

async def manejar_conversacion(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    texto = update.message.text
    user_id = user.id
    now = datetime.now()

    # Verificar si el usuario est√° en cooldown por spam
    if user_id in user_spam_control and user_spam_control[user_id]['in_cooldown']:
        if user_spam_control[user_id]['cooldown_until'] > now:
            # Todav√≠a en cooldown, no responder
            return WAITING_RESPONSE
        else:
            # Cooldown terminado
            user_spam_control[user_id]['in_cooldown'] = False
            user_spam_control[user_id]['message_count'] = 0

    # Control de spam: mensajes muy frecuentes
    if user_id in user_spam_control:
        time_since_last = (now - user_spam_control[user_id]['last_message_time']).total_seconds()
        
        if time_since_last < 1:  # Mensajes demasiado r√°pidos
            user_spam_control[user_id]['message_count'] += 1
            if user_spam_control[user_id]['message_count'] > 5:
                user_spam_control[user_id]['in_cooldown'] = True
                user_spam_control[user_id]['cooldown_until'] = now + timedelta(seconds=COOLDOWN_TIME)
                await update.message.reply_text(random.choice(RESPUESTAS["spam"]))
                return WAITING_RESPONSE
        else:
            user_spam_control[user_id]['message_count'] = max(0, user_spam_control[user_id]['message_count'] - 1)
        
        user_spam_control[user_id]['last_message_time'] = now

    if user_id not in conversaciones:
        return await start(update, context)
    
    # Control de mensajes repetidos
    if texto == conversaciones[user_id].get('ultimo_mensaje'):
        conversaciones[user_id]['repeticiones'] += 1
        if conversaciones[user_id]['repeticiones'] >= MAX_REPEATED_MESSAGES:
            await update.message.reply_text(random.choice(RESPUESTAS["repetido"]))
            return WAITING_RESPONSE
    else:
        conversaciones[user_id]['ultimo_mensaje'] = texto
        conversaciones[user_id]['repeticiones'] = 0
    
    tema = determinar_tema(texto)
    conversaciones[user_id]['pasos'] += 1
    
    # Manejar despedidas
    if tema == 'despedida':
        respuesta = random.choice(RESPUESTAS["despedida"])
        del conversaciones[user_id]
        if user_id in user_spam_control:
            del user_spam_control[user_id]
        await update.message.reply_text(respuesta)
        return ConversationHandler.END
    
    # Determinar respuesta apropiada
    if tema:
        respuesta = random.choice(RESPUESTAS.get(tema, RESPUESTAS["no_entendido"]))
        conversaciones[user_id]['ultimo_tema'] = tema
    else:
        if conversaciones[user_id]['ultimo_tema']:
            respuesta = f"{random.choice(RESPUESTAS['no_entendido'])}\n\n¬øQuieres m√°s informaci√≥n sobre {conversaciones[user_id]['ultimo_tema']} contactanos?"
        else:
            respuesta = random.choice(RESPUESTAS["no_entendido"])
    
    # Hacer la conversaci√≥n m√°s natural
    if conversaciones[user_id]['pasos'] > 3 and "?" not in respuesta:
        respuesta += "\n\n¬øHay algo m√°s en lo que pueda ayudarte?"
    
    await update.message.reply_text(respuesta)
    return WAITING_RESPONSE

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if user.id in conversaciones:
        del conversaciones[user.id]
    if user.id in user_spam_control:
        del user_spam_control[user.id]
    await update.message.reply_text("¬°Hasta luego! üòä Fue un placer ayudarte.")
    return ConversationHandler.END

async def error_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    logger.error(f"Error: {context.error}", exc_info=True)
    if update.message:
        await update.message.reply_text("Ocurri√≥ un error inesperado. Por favor intenta nuevamente m√°s tarde.")

def main():
    # Configuraci√≥n para Render
    TOKEN = os.getenv('TELEGRAM_TOKEN', '7841638412:AAGso5OXD-tsQhRJxNPXH1LTHH66XzQ_S0g')
    PORT = int(os.getenv('PORT', 5000))
    WEBHOOK_URL = os.getenv('WEBHOOK_URL')
    
    application = Application.builder().token(TOKEN).build()
    
    # Handlers
    conv_handler = ConversationHandler(
        entry_points=[CommandHandler('start', start)],
        states={
            WAITING_RESPONSE: [MessageHandler(filters.TEXT & ~filters.COMMAND, manejar_conversacion)]
        },
        fallbacks=[CommandHandler('cancel', cancel)],
        allow_reentry=True
    )
    
    application.add_handler(conv_handler)
    application.add_error_handler(error_handler)

    # Modo webhook para Render
    if WEBHOOK_URL:
        logger.info("Iniciando en modo webhook...")
        application.run_webhook(
            listen="0.0.0.0",
            port=PORT,
            webhook_url=WEBHOOK_URL,
            secret_token='SECRETO_UNICO'
        )
    else:
        # Modo polling para desarrollo local
        logger.info("Iniciando en modo polling...")
        application.run_polling()

if __name__ == '__main__':
    main()
